AMQP (Advanced Message Queuing Protocol) - это открытый протокол для передачи сообщений между программами в ОС (win, lin). 
Его идея в том, что бы независмые программы могли обмениваться сообщениями не зная о друг друге через AMQP-брокер.
AMQP-брокер под собой маршрутизирует сообщения, может быть очень удобно расширяем с той целью, 
что бы приложение отправитель не имело понятия где может находится нода которой оно отправляет сообщение, сколько этих нод, на каких ОС. Ей это и не интересно.

AMQP-брокер может дополнительно - гарантировать доставку, распределять потоки сообщений, реализовывать подписку на нужные типы сообщений, быть масштабируемым, платным.


В протокол AMQP входит 3 понятия:
1. exchange (обменник или точка обмена) - в обменник отправляются сообщения. 
	Обменник отправляет сообщения в одну или несколько очередей. 
	Маршрутизация происходит на основе созданных связей (binding) между ним и очередью.
2. queue (очередь) - структура данных на диске или в оперативной памяти, которая хранит ссылки на сообщения и отдаёт копии сообщений consumers (потребителям).
	Одна очередь (queue) может использоваться несколькими потребителями. 
	В очередь сообщения попадают с помощью обменника, который выбрал очередь по её связи с сообщением или своей конфигурации и загрузил в неё копию сообщения.
3. binding (связь, привязка) - правило, привязанное к очереди, которое сообщает обменнику (exchange) должно ли попасть в queue сообщение.

Протокол AMQP работает поверх TCP/IP.

Подключение осуществляется отправкой брокеру RPC команды Start, ожидая обратно команду StartOk.
Так же и брокер и тот кто к нему подключился принимают от друг друга RPC команды/методы.
Для такого обмена командами и информацией используются каналы. Каналы создаётся в рамках подключения. Тоесть у одного подключения может быт ьнесколько каналов.
Каждый канал полностью изолирован от других возможных каналов.
То есть, для того что бы отправлять команды параллельно - нужно их отправлять через разные каналы.

Грубо говоря это связь по телефону с компанией авиарейсов. 
Вы звоните и в рамках одного звонка договариваетесь о том, что будете заказывать ин одного, а несколько доступных таксистов, что бы отправлять товары параллельно, которые нужно поставлять в exchanges.
Тоесть канал (channel) это умный таксист авиакомпании, с помозью которого можно взаимодействовать с exchanges и получать посылки, а так же обмениваться информацией с брокером.

Утверждение неверное - Ограничений по количеству таксистов - нет. То есть можно создавать сколько угодно таких каналов в рамках подключения (общения по телефону). 1000 таксистов примерно 1 мб оперативной памяти.
Ограничений и правда нет, но таксисты это сборка сервиса, которая запускается как erlang процесс. Тоесть на каждый канал (каждый таксист) это отдельный Erlang процесс в ОС.
Поэтому - чем больше каналов при подключении, тем больше RabbitMq использует памяти, для управления такими соединениями (по телефону). Общениями с таксистами.

Открывать новые соединения с брокерами крайне не рекомендуется. Это очень затратная операция.
Каналы (таксисты), тоже должны быть постоянными, а не пересоздаваться заново. Всё это тяжёлые операции для брокеров. Хотя это и не запрещено, можно пересоздавать, управлять, отключать каналы (таксистов).

Краткий алгоритм работы:
1. Приложение приёмник подключается кexchange 
1. Приложение источник подключается к брокеру и отправляет сообщение с определённым ключём или без в указанный exchange
2. exchange смотрит или не смотрит ключ, в зависимости от своих настроек, выбирает queues, по их binding'ам, и отправляет им ссылку на сообщение (в опер. памяти или на диске)
3.