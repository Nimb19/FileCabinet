static class System.Threading.Volatile
https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.volatile?view=net-6.0

Вроде круче чем ключ. слово volatile, но нет, скорее всего при ключ. слове volatile

https://ru.stackoverflow.com/questions/535410/%D0%9F%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B8%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-volatile-read-write

Предыстория - Компилятор имеет полное право передвигать инструкции так, что бы в одном конкретном потоке - логика не нарушалась. 
Для разных процессоров оптимизация идёт по разному, для каких то (под x86) почти нет перестановок, для ARM - очень жестокие.
И со временем оптимизаций будет только больше.

!!! Предыстория для операций чтения - компилятор имеет полное право не перечитывать переменную, если видит что в данном потоке она не меняется.
	! Однако операции Volatile.Write/Read, lock, Thread.Start/Join и т.п. 
	  являются критическими точками для компилятора, и оптимизация проходит только между ними.

!!!!!!! Поведение под отладкой и в Release - тут действительно сильно может повлиять на результат оптимизации

Volatile.Read - считывает значение поля, предотвращая процессор в изменении порядка операций с памятью:
	! если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить её перед этим методом
	  НО, любые операции до, смогут быть передвинуты на после этого метода
	- ОБЯЗАТЕЛЬНО честно перечитывает переменную заново, без всяких оптимизаций


Volatile.Write - записывает указанное значение не в кэш, и не сдвигает запись дальше, а напрямую в память сразу.
	! То что было до этого метода не сможет быть выполнено после него, он будет обязательно выполнено ДО.
	  НО, операции и чтения и записи после этого метода вполне по описанию могут сдвинуться до этого метода

Вообщем то методы гарантируют, что внутри потока никакие вычисления ни над какими переменными не сдвинуться между этими словами обычно.

!!!
Враги снизу.
Чтение защищает от врагов.
А запись нападает, устраивает переворот тем кто выше, и не пропускает их ниже. Всё что ниже может пропустить наверх. Но не пропустит то что было сверху - вниз

Write
// гарантируется, что между ничего не будет - относится только к другим переменным
Read


Read
// то что будет между может быть смешано, но не может выйти за рамки - относится только к другим переменным
Write