Барьеры памяти и неблокирующая синхронизация в .NET
https://habr.com/ru/post/130318/

!!! Любой современный процессор может переставлять инструкции чтения и записи памяти в целях оптимизации.

Пример:
int a = _a;
_b = 10;

Функции загрузки и записи могут легко быть переставлены современным процессором. 
Для однопоточной программы никаких проблем не возникнет, а для многопоточной могут быть проблемы.

Цель следующих функций (VolatileRead, VolatileWrite и MemoryBarrier) побеждать эту проблему.


Модель памяти

Совокупность правил перестановок таких инструкций называется - Моделью памяти.
Платформа .NET имеет собственную модель памяти, которая абстрагирует нас от модели памяти конкретного процессора.

Тип перестановки - разрешена ли она
1) Загрузка-загрузка - ДА
2) Загрузка-запись - ДА
3) Запись-загрузка - ДА
4) Запись-запись - НЕТ

!!! НО Когда мы говорим о перестановках инструкций, то имеется ввиду перестановка инструкций одного потока, читающих/пишущих разные переменных.
    Если в разных потоках идёт запись в одну и ту же переменную, то их порядок в любом случае случаен. 
    И если мы говорим о чтении и записи одной и той же переменной, к примеру, вот так:

    var a = GetA();
    UseA(a);

    то, понятно, что перестановок здесь быть не может.

Рассмотрим пример:

Процедуры Foo и Bar запускаются одновременно из разных потоков.
Является ли данный код корректным, то есть, можем ли мы с уверенностью сказать, что программа никогда не выведет нуль?

class ReorderTest2
{
   private int _a;
   private int _b;

   public void Foo()
   {
       _a = 1;
       _b = 1;
   }

   public void Bar()
   {
       if (_b == 1)
       {
           Console.WriteLine(_a);
       }
   }
}

Теперь можно рассмотреть наш пример с точки зрения модели памяти .NET. 
Так как перестановка запись-запись запрещена, 
то запись в переменную _а всегда будет происходить до записи в переменную _b, и здесь программа отработает корректно. 
Проблема находится в процедуре Bar. Так как перестановка инструкций чтения не запрещена, то переменная _b может быть прочитана до _a.
После перестановки код будет исполняться так, как будто он был написан следующим образом:

var tmp = _a;
if (_b == 1)
{
    Console.WriteLine(tmp);
}