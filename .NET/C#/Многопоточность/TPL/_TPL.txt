Task Parallel Library (TPL)
https://learn.microsoft.com/ru-ru/dotnet/standard/parallel-programming/task-parallel-library-tpl


Библиотека параллельных задач создана для повышения производительности разработчика. 
Кроме того, TPL обработчики эффективно распределяют свои задачи используя ThreadPool, эффективно управляют своим состоянием 
и выполняют другие низкоуровневые задачи.
Смысл ещё в том, что бы Task при запуске брал какой то готовый поток из пула, быстро выполнял какую-то задачу и возвращал поток в пул.
То есть фишка в том, что программист не заботится о каких вещах связанных с процессорами 
- будет ли выгодно распараллеливать на текущей конфигурации, 
- хватает ли процессоров что бы распараллелить какую то задачу эффективно,
- не надо следить за пулом потоков по большому счёту

Нужно просто взять и писать бизнес логику распараллеливая её с помощью TPL и .NET за тебя всё эффективно настроит для удобного распараллеливания.
Добавляя читаемости кода.

Классы библиотеки находятся в System.Threading и System.Threading.Tasks (основной функционал) пространствах.

Вспомогательные типы, обеспечивающие эту функциональную возможность, 
включают в себя ParallelLoopState, ParallelOptions, ParallelLoopResult, CancellationToken и CancellationTokenSource.


!! https://stackoverflow.com/questions/37607911/when-to-use-taskcreationoptions-longrunning
   LongRunning поток считается поток более чем на пол секунды. Пишут это более 4 миллиардов инструкций у современного компа в 2016.
   Вообще этот энум у Task'а просто для того что бы получить практически гарантированное и немедленное исполнение. 
   Подходит для медленных и не очень эффективных операций по типу сбора статистики, прогресса, всякой херни.

! Отмечу, что не всякий код может быть эффективно паралелизован. 
  При малом количестве кода, который можно параллелить - создание отдельного потока будет затранее, чем сделать его синхронным.

! Возможные проблемы при использовании TPL
  https://learn.microsoft.com/ru-ru/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism
  : 
  . Потенциальные ошибки, связанные с параллелизмом данных и задач
  . Не считайте, что параллельные процессы всегда быстрее
  . Избегайте размещения в общей памяти
  . Помните о проблемах сходства потоков
  . Избегайте вызова методов, небезопасных для потоков
  . Избегайте выполнения параллельных циклов в потоке пользовательского интерфейса. Поток блокируется пока не завершится цикл!
  . Не считайте, что итерации операторов ForEach, For и ForAll всегда выполняются параллельно, на это нет гарантий, так же, как и на последовательность
  . Нельзя ожидать какое то событие из параллельно работающего кода 
	В ТОМ ЖЕ параллельно работающем коде, потому что в цикле работает ограниченное кол-во потоков, все из которых могут заблочится
  . Ограничение вызовов потокобезопасных методов 
	(ожидание стат. или потокобезопасных используют блокировки и синк, которые могут только замедлить процесс (WriteLine к примеру))
  . Избегайте излишней параллелизации
	Использование параллельных циклов связано с чрезмерными затратами ресурсов на секционирование исходной коллекции и синхронизацию рабочих потоков
	Чаще всего излишняя параллелизация возникает во вложенных циклах. 
	Если не выполняется хотя бы одно из следующих условий, в большинстве случаев выгоднее параллелизовать только внешний цикл:
	| Внутренний цикл очень длинный
	| С каждым заказом вы выполняете дорогостоящие вычисления. (Операция, показанная в примере, не является дорогостоящей.)
	| Целевая система имеет достаточно процессоров для обработки того количества потоков, которое будет создано при параллелизации запроса в cust.Orders.
	| В любом случае лучший способ определения оптимальной формы запроса — это проверка и измерение.
