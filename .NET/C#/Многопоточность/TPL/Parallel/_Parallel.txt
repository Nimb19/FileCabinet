static Parallel (TPL)
https://learn.microsoft.com/ru-ru/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library


Особенности: 
1. https://stackoverflow.com/questions/37133104/performances-of-plinq-vs-tpl
И PLINQ и Parallel в первую очередь создавались для рабочих нагрузок, поэтому там присутствует высокая степень оптимизации 
	(смотрят на доступные ресурсы компьютера, распределяют задачи оптимальным образом по процессорам, если нагрузка становится не сбалансированной), 
которая, на маленьких объёмах данных, может только мешать процессу (например обычные потоки ввода/вывода значения в WriteLine).

Поэтому на больших коллекциях/больших кусках кода в потоках - выгоднее будет использовать подобное распараллеливание. 
Хотя это не доказано и по большому счёт нужно профилировать приложение, измерять что будет использовать выгоднее.

2. При этом Parallel разделяет источник по нескольким частям, что бы цикл мог параллельно работать, 
и даже позволяет задать собственный разделитель или планировщик.
3. Позволяет: 
	отслеживать состояние цикла из другого потока;
	прервать цикл токеном отмены;
	обслуживать локальное состояние потока;
	управлять степенью параллелизма.

Методы: 
(ParallelLoopResult - структура, которая говорит был ли завершён цикл и на какой итерации, если был)

Статические методы:
1. ParallelLoopResult For(iStart, iLenghth, Action<int>) - как и банальный цикл for принимает стартовый и последний индекс, передаёт его в делегат
2. ParallelLoopResult ForEach(IEnumerable<T>, Action<T>) - загружаем коллекцию и берём из неё с помощью делегата значения параллельно
3. Task ForEachAsync() - само за себя говорит
4. void Invoke() - не всегда код запустится параллельно, иногда синхронно

Перегрузки поддерживают типизированные доступ (<T>), токены отмены, различные настройки распараллеливания //TODO: допиши.


Впринципе можно особенности глянуть в книге
Шаблоны параллельного программирования: описание и применение в .NET Framework 4.