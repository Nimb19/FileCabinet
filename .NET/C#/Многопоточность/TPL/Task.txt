System.Threading.Tasks.Task
https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.tasks.taskcreationoptions?view=net-6.0#system-threading-tasks-taskcreationoptions-attachedtoparent

ConfigureAwait: 
  НЕ НАДО ConfigureAwait: 
  	await (Task(WorkAsync())).ConfigureAwait(false) означает - мне всё равно, в каком SynchronizationContext будет выполнятся хвост метода (строки после этой).
  	Таким образом остальные строки так же могут выполнится в потоке, в котором выполнялся WorkAsync(), что бы лишний раз оптимизировать процесс.
  	Фишка в том, что нет никакой гарантии, что контекст изменится, поэтому в библиотеках приходится бесконечно указывать ConfigureAwait(false).
  	https://ru.stackoverflow.com/questions/681382/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-configureawaitfalse
  НАДО await AsyncHelper.RedirectToThreadPool();
    // всё, мы гарантировано не в контексте вызывающего потока


! Task.Run эквивалентна Task.Factory.StartNew(action, CancellationToken.None, TaskOptions.DenyChildAttach, TaskScheduler.Default)
  !! Поэтому любая дочерняя задача созданная в этом потоке - будет отменять присоединение дочерней.

! Если задача будет присоединена (AttachedToParent), то:
	1. Родительский объект станет ожидать завершения дочерней/всех дочерних.
	2. Родительский объект станет выбрасывать то же исключение, которое было создано дочерней.
	3. Состояние (отменена или нет) родительского объекта зависит от состояния дочернего/дочерних.

	В большинстве случаев нужно использовать отсоединённые дочерние задачи, поскольку их связи с другими задачами менее сложные, обычно это не надо. 
	Поэтому по умолчанию задачи отсоединены, то есть не зависят никак от результатов/синхронизации/работы друг друга, 
	если это логически не задать явно вызвав .Result или ожидая завершение дочерней.

	Основной посыл - все родительские задачи ждут завершение их присоединённых дочерних, по умолчанию это никогда не нужно.
	!!! Даже если родительская отменена, то она продолжает ожидать завершения дочерней

	!! Это значит, что, по умолчанию, если основной поток завершится, то автоматически завершаться и отсоединённые по умолчанию дочерние.
	   Если они будут присоединены явно, то родительская задача будет жить и ожидать завершение дочерней, даже если сама выбросила ошибку, она ждёт завершения дочерней.
	   В итоге все ошибки во время выполнения родительской собираются в AggreagateException и смотрятся foreach'ем через Flatten (выравнивание).

	! Если поток родительской завершился и ждёт дочернюю

	Родительская задача явно может указать что не примет присоединение дочерних, даже если они будут созданы с флагом присоединения 
	Присоединены могут быть сколько угодно дочерних задач

TaskCreationOptions
0. None - поведение по умолчанию
1. PreferFairness - рекомендация для TaskScheduler, что бы тот старался выполнить Task более менее по его порядку запуска, относительно других задач
2. LongRunning - указание для TaskScheduler, что поток не очень оптимальный и очень долгий (больше 500мс идёт), 
   что бы тот создал если надо ещё один поток, а не ждал этого, например. Следует ожидать избыточной подписки.
   Подсказывает планировщику, что этой долгой задаче может потребоваться ещё одна задача, что бы были какие то лишние свободные потоки.
   + достаточно быстро запускает задачу, судя по описанию.
4. AttachedToParent - Сцепляет создаваемую задачу к родительской, от чего родительская зависит от дочерней. 
					  ! По умолчанию Task.Run не цепляется, ещё и сам говорит - не буду цеплять в опции. Такой таск не может быть родительским.
8. DenyChildAttach - запрещает быть родителем создаваемому таску
16. HideScheduler - не позволяет видеть внешний планировщик как текущий. 
	Означает что создаваемые внутри задачи или присоединяемые через ContinueWith - будут использовать дефолтный планировщик.
64. RunContinuatationsAsynchronously - принудительное асинхронное выполнение продолжений, добавляемых в текущую задачу