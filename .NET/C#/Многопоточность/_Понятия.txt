1. Домен синхронизации (Synchronization domain) - 
В контексте синхронизации потоков - набор контекстов и объектов, совместно использующих одну блокировку.

2. При параллелизации любого кода главная цель - использовать ресурсы компа на максимум, без чрезмерной параллелизации
   В большинстве систем - лучший способ использовать многопоточность и параллелизацию, так что бы это было бы выгоднее - использовать для внешних циклов.
   А для внутренних только если большой кусок кода.
	   - Внутренний цикл очень длинный
	   - С каждым заказом вы выполняете дорогостоящие вычисления
	   - Целевая система имеет достаточно процессоров для обработки того количества потоков, которое будет создано при параллелизации запроса

3. Вне локов и блокировок - при изменении/чтении каких то численных переменных из разных потоков есть два пути, которые обычно не надо совмещать:
   a) volatile, Volatile.Read/Write - будет без оптимизаций читать переменную, НО, не путать с оптимизациями чтения/записи других переменных в текущем потоке.
      Не безопасно при наращении. Потому что, что бы прибавить что нибудь или отнять надо прочитать, прибавить и присвоить, что не поможет при гонке потоков.
	  Защищает от оптимизаций (перемещения чтения/записи ДРУГИХ переменных в текущем потоке), но не защищает от гонки потоков записи/чтения.
   b) Interlocked - будет записывать атомарно и напрямую в память. 
	  Потокобезопасно всегда из-за атомарности добавления и чтения напрямую из памяти, очищая кэш если он был между где то.
	  Защищает от гонки потоков записи/чтения, но не от оптимизаций (перемещения чтения/записи ДРУГИХ переменных в текущем потоке).

	От оптимизаций чтения из кэша, а не из памяти - защищают оба способа. Поэтому значение всегда в обоих случаях будет актуальным.
	А вот значение других переменных, нифига может не быть актуальным.

	Вообщем, судя по форумам, смешивать volatile и Interlocked может быть вполне полезно, 
	но volatile всегда добавляется, если речь о нескольких переменных, которыми орудуем между потоками 
	(ИЛИ, если мы не используем Interlocked, появляются другие страхи оптимизации, которые могут повлиять и на одну переменную, поэтому надо всё таки volatile).
	А Interlocked не нужно, когда нет гонки потоков на запись/чтение. Такое бывает когда единично из какого нибудь потока должны выставить, например bool.
	Если есть гонка и переменных, которые как то зависят от состояния друг друга, несколько (от чего оптимизация опасна), то надо смешивать.

	Банальный пример - булева переменная, к примеру, отмены (_isCancel). 
	Ждём пока все потоки (на обновление чего-нибудь параллельно) завершаться, 
	после чего в основном должны перечитать переменную и проверить, выставил ли кто то флаг отмены в true.
	И что бы гарантированно проверять/записывать состояние из каждого потока, 
	либо каждый раз нужно выставлять Volatile.Write/Read, либо ключ. словом volatile выставить переменную.

	+ volatile подходит для классов, например надо иногда в переменной назначать/обновлять ссылку на объект.
	  Если хотя бы что то из этого может быть правдой и какой то поток вполне может изменить ссылку на другую 
	  или изменить на null, или назначить что то вместо null - то обязательно надо использовать volatile.