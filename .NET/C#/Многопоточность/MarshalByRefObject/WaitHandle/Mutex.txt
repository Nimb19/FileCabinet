System.Threading.Mutex : System.Threading.WaitHandle

! Тот же lock (Monitore.Enter) - но для передачи через границы домена приложения. + в отличии от lock будет всё таки по тяжелее.

Примитив синхронизации, который может использоваться в межпроцессорной синхронизации.

1. mutex.WaitOne() - ждёт получения лока
2. bool result = mutex.WaitOne(Int32) - ждёт получения лока указанное кол-во мс. Если его нет, то возвратит false.
3. mutex.ReleaseMutex() - отпускает блокировку

! :( Нет перегрузки для CancellationToken

! Использует удостоверение потока, поэтому ReleaseMutex (да и в принципе любым способом освобождение блокировки) может вызвать только поток, который брал блокировку.
	В отличии кстати от Semaphore.

! Поток может запрашивать WaitOne несколько раз, но должен такое же кол-во раз вызвать ReleaseMutex

! Так как наследуется от WaitHandle, можно экземпляры Mutex'а использовать для ожидания в статических методах:
	1. WaitHandle.WaitAll(WaitHandle[] handles)	
	2. WaitHandle.WaitAny(WaitHandle[] handles)
	+ перегрузки с указанием ожидаемого времени
	+ перегрузка с флагом выхода из домена синхронизации до начала ожидания * не знаю что это, что то связано с SynchronizationContext

Если программа не освободит мьютекс и завершится - он так и останется висеть в системе. обычно такие истории говорят о проблеме в коде.
Следующий поток, который захочет обираться к мьютексу получит ошибку AbandonedMutexException, 
	что означает - некоторый поток получил Mutex, брошенный другим потоком.

Например, системные мьютексы могут быть не освобождены в случае убийства программы, к примеру с помощью Диспетчера задач.


Существуют несколько видов Mutex:
1. Локальный - существует только в родном процессе. Может использоваться только по ссылке внутри приложения
2. Системный не именованный - так же как и локальный - может использоваться только по ссылке внутри приложения
3. Системный именованный - виден во всей ОС, может использоваться для синхронизации между процессорами

Для создании системного именованного - достаточно в конструкторе прописать имя мьютексу. 
После этого ОС либо создаст, либо подключиться к существующему мьютексу. 
Для того, что бы явно подключиться к текущему мьютексу - OpenExisting(name).

! На терминальных серверах у мьютексов есть область видимости:
1) Если имя мьютекса начинается на 'Global\' - он виден всем;
2) Если на 'Local\' - то виден только текущему сеансу терминала (где он был создан).
   В этом случае мьютексы могут существовать с одинаковым именем, но в разных сеансах.
   ! Если пи создании именованного мьютекса не используется явный префикс - по умолчанию он будет с префиксом Local\.
   !! Префикс задаёт область видимости имени относительно сеансов, а не относительно процессов.
   Обратная косая черта '\' является зарезервированным символом в имени Mutex, поэтому этот символ ('\') нельзя указывать просто так. 
      Возникнет ошибка DirectoryNotFoundException

Пример:
public Mutex (bool initiallyOwned, string? name, out bool createdNew);
	initiallyOwned - Если мьютекс был создан данным вызовом, то он будет автоматически захвачен текущим потоком.
	name - имя мьютекса. Если будет пустая строка или null, то мьютекс не будет виден в системе.
	out bool createdNew - возвращает результат - был ли мьютекс создан (либо же мы подключились к уже существующему именованному)
