System.Threading.Monitor
Статический класс, вспомогательный для разделения доступа к каким-либо ресурсам/блокам кода.

Например: конструкция lock(object){ // блок кода, который может выполняться только в одном потоке \\ }
Она под капотом использует:
```
(1) Monitor.Enter(object); // Получает монопольную блокировку указанного объекта. Если блокировка кем то уже взята и не отпущена, то блокирует поток пока не получит
try
{
	// блок кода, который может выполнятся только в одном потоке \\ 
}
finally
{
	(2) Monitor.Exit(object); // Отпускает блокировку указанного объекта
}
// так же существует полезная перегрузка Monitor.Enter(object, ref bool была ли выдана блокировка);
```

(3) bool IsEntered(object) - возвращает значение, блокирован ли текущий объект ТЕКУКЩИМ потоком ! 
(естественно работает только если блокировка была вызвана с помощью класса Monitor)


=============================================================================================
Теперь серьёзно: Wait() (не путать с Task.Wait()), Pulse(), PulseAll().
https://professorweb.ru/my/csharp/thread_and_files/1/1_10.php

Во первых, методы позволяют обмениваться сообщениями между потоками.
Они существуют в ситуациях, когда в блоке кода, который мы залочили, требуется подождать освобождение какого то ресурса. 
Что бы не блокировать выполнение потоков, которые ожидают разблокировки нашего объекта (а мы заблочились в процессе и ожидаем какой-то ресурс). 
Мы используем команды:

! Могут вызываться только из заблокированного участка кода!

4. Wait() - отпускаем блокировку залоченного объекта и входим в режим ожидания (пока не будет вызван Pulse или PulseAll любым другим потоком под нужным лок объектом)
   + перегрузка с Int32 - кол-во мс, которое ждём освобождения. После них освобождаемся сами.
5. Pulse()  - снимает ожидание у одного потока, вызванное через Wait(), что переведёт случайный поток из очереди ожидания в очередь готовности для текущего лок объекта
6. PulseAll() - то же, что и Pulse(), но для всех ожидающих потоков, что переведёт их всех в очередь готовности

! https://stackoverflow.com/questions/675352/difference-between-monitor-pulse-and-monitor-pulseall
  В Monitor существуют две очереди - очередь ожидания и очередь готовности для каждого из залоченных объектов.
  Когда мы лочим объект, то другой поток ожидая lock - ожидает в очереди готовности.
  А когда мы жмём Wait() - поток переходит в очередь ожидания.
  ! отличие очередей в том, что только из очереди готовности потоки могут получить лок объекта.
  То есть пока поток в очереди ожидания - они ждут Pulse() и не смогут получить лок.