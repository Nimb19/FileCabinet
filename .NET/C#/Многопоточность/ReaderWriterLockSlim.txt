ReaderWriterLockSlim

ќчень похож на обычный lock (Monitor.Enter, Monitor.Exit), Ќќ
 онцептуально позвол€ет лочить двум€ способами:
1) «аписывающей блокировкой (Write lock) - работает как обычный lock (блокирует потоки которые будут пытатьс€ в Reader lock)
2) Ѕлокировкой на чтение (Reader lock) - крутой lock, позвол€ет другим Read потокам заходить в lock.

(так же их Try версии, которые попробуют вз€ть лок и вернут bool значение о том, получилось ли и в любом случае пойдут дальше, под коробкой они не заблочатс€)

“ак же добавлено:
a) EnterUpgradeableReadLock() - проапргейдженный лок на чтение, который позвол€ет позже получить лок на запись, после прочтени€ значени€ (+ try верси€)

Exceptions:
ћожет вызвать LockRecursionException (https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.lockrecursionexception?view=net-6.0) 
	- выбрасываетс€, если рекурсивное (повторное) использование какого то из lock'ов не было предусмотрено политикой.
	ѕолитика по умолчанию запрещает брать lock повторно (то есть рекурсивно), но, это можно разрешить.

	Ќапример: вз€тие 2 раза подр€д lock'а через EnterReadLock() 
		(LockRecursionException: Recursive read lock acquisitions not allowed in this mode.)
	»ли: вз€тие EnterReadLock(), затем EnterWriteLock() 
		(LockRecursionException: Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Consider using the upgrade lock.)