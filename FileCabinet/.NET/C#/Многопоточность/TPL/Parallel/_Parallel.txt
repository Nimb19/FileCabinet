static Parallel (TPL)
https://learn.microsoft.com/ru-ru/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library

„то выбрать Parallel или PLINQ? ¬ общем случае Parallel быстрее будет останавливать потоки
	https://habr.com/ru/post/135942/

ThreadSafe статический класс

ќсобенности: 
1. https://stackoverflow.com/questions/37133104/performances-of-plinq-vs-tpl
» PLINQ и Parallel в первую очередь создавались дл€ рабочих нагрузок, поэтому там присутствует высока€ степень оптимизации 
	(смотр€т на доступные ресурсы компьютера, распредел€ют задачи оптимальным образом по процессорам, если нагрузка становитс€ не сбалансированной), 
котора€, на маленьких объЄмах данных, может только мешать процессу (например обычные потоки ввода/вывода значени€ в WriteLine).

ѕоэтому на больших коллекци€х/больших кусках кода в потоках - выгоднее будет использовать подобное распараллеливание. 
’от€ это не доказано и по большому счЄт нужно профилировать приложение, измер€ть что будет использовать выгоднее.

2. ѕри этом Parallel раздел€ет источник по нескольким част€м, что бы цикл мог параллельно работать, 
и даже позвол€ет задать собственный разделитель или планировщик.
3. ѕозвол€ет: 
	отслеживать состо€ние цикла из другого потока;
	прервать цикл токеном отмены;
	обслуживать локальное состо€ние потока;
	управл€ть степенью параллелизма.

ћетоды: 
(ParallelLoopResult - структура, котора€ говорит был ли завершЄн цикл и на какой итерации, если был)

—татические методы:
1. ParallelLoopResult For(iStart, iLenghth, Action<int>) - как и банальный цикл for принимает стартовый и последний индекс, передаЄт его в делегат
1. ParallelLoopResult ForEach(iStart, iLenghth, Action<int>) - допиши если интересно
2. Task ForEachAsync() - само за себ€ говорит
3. void Invoke(ParallelOptions, Action[]) - не всегда код запуститс€ параллельно, иногда синхронно

„исто For* операции, без Linq методов. + Invoke конечно.