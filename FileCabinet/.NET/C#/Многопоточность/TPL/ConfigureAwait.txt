System.Threading.Tasks.Task.ConfigureAwait()
https://devblogs.microsoft.com/dotnet/configureawait-faq/

! ConfigureAwait(true) - просто бесполезный, максимум предупреждения компилятора убрать. Можно смело удалять.

!! Если прямо вызывается methodasync.ConfigureAwait(false).GetAwaiter().GetResult() - ConfigureAwait(false) бесполезен, 
   т.к. он влияет только на OnCompleted, а тут мы синхронно ждём результат и продолжим дальше.

!! В общем случае есть два правила:
    Если код приложения у которого есть своя логика, завязанная на синк контекст (WPF, WinForm), ConfigureAwait(false) - не использовать
    Если код библиотечный - использовать
        Исключение - работа с делегатами внутри библиотеки, надо быть аккуратнее с ConfigureAwait(false)
        ! С огромной вероятностью, если в библиотеке не используется ConfigureAwait(false) - это баг, хоть и не критичный.

await ConfigureAwait(bool continueOnCapturedContext) - говорит важно ли в каком потоке будет выполнятся хвост метода.
Если False - то хвост метода может быть выполнен тем же потоком, в котором обрабатывалась какая-то асинхронная задача 
(если этот поток вообще выдавался, а не Task.FromResult вернулся).

Зачем использовать ConfiureAwait(false) (избегать принудительного вызова колбэка в исходном контексте или планировщике)?:
    Что бы повысить производительность
    Избежать взаимоблокировок (от ограничения выполняемых задач, к примеру, как в UI, где только 1 задача может выполнятся)
        Представим себе что мы в UI потоке, который стукнулся в .Wait()/Result и т.д., Task захватит текущий SyncContext.
        После того как загрузка в тред пуле пройдёт, она поставит хвост метода в SyncContext, но т.к. SyncContext ограничен одним потоком, 
        она не дождётся завершения, т.к. она уже заблокировала свой поток ожидая выполнения .Wait()/Result. 
        Та же история и с неявным ограничением ресурсов компьютера, если они сильно ограничены 
        есть неплохая вероятность того что макс. кол-ва потоков не хватит, в случае большого кол-ва потоков.
По умолчанию контекст потока захватывается, что бы выполнить следующие задачи
```
object scheduler = SynchronizationContext.Current;
if (scheduler is null && TaskScheduler.Current != TaskScheduler.Default)
{
    scheduler = TaskScheduler.Current;
}
```

Но, грубо говоря, с ConfigureAwait взятие контекста выглядит так
```
object scheduler = null;
if (continueOnCapturedContext)
{
    scheduler = SynchronizationContext.Current;
    if (scheduler is null && TaskScheduler.Current != TaskScheduler.Default)
    {
        scheduler = TaskScheduler.Current;
    }
}
```

Другими словами, при указании false, даже если есть текущий контекст или планировщик для обратного вызова, он делает вид, что их нет.
```
Task.Run(async delegate
{
    SynchronizationContext.SetSynchronizationContext(new SomeCoolSyncCtx());
    await SomethingAsync(); // will target SomeCoolSyncCtx
});
```

! Нет никакой гарантии, что await в конечном итоге вызовет обратный вызов/продолжение в исходном потоке, 
а это означает, что сброс SynchronizationContextвозврата к исходному может фактически не произойти в исходном потоке, 
что может привести к тому, что последующие рабочие элементы в этом потоке увидят неправильный контекст
```
SynchronizationContext old = SynchronizationContext.Current;
SynchronizationContext.SetSynchronizationContext(null);
try
{
    await t;
}
finally { SynchronizationContext.SetSynchronizationContext(old); }
```


https://ru.stackoverflow.com/questions/681382/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-configureawaitfalse
````
PS

Попробую объяснить на примере тренера, футболистов и мячей. Где мяч - это поток. Тренер разговаривает с футболистом (синхронное выполнение). Тренер может пнуть мячь и сказать беги. Так он может сделать для всех 11 футболистов с 11 мячами-потоками. Но в твоём коде он делает следующее:

разговаривает
пинает мяч.
ждёт пока футболист его принесёт, при этом сам занят другими делами, не занимает мяч.
дальше разговаривает
дальше пинает мяч в др. сторону.
ConfigureAwait(false) нужно было бы для случая:

тренер разговаривает с первым футболистом
пинает мяч, первый футболист убежал, забрав поток-мяч
тренер разговаривает со вторым футболистом
в это время первый прибежал, ждёт новый удар. Но тренер все ещё говорит со 2ым футболистом.
Так вот в случае с ConfigureAwait(false) футболист берёт любой свободный мяч и, не отвлекая тренера, продолжает тренировку (бьёт мяч и убегает). Потому что ему уже не важен контекст (указания тренера) или он всё записал на бумажечку(сохранил контекст)

````