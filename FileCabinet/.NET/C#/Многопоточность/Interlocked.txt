static System.Threading.Interlocked
https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.interlocked?view=net-6.0


! При обращении ради записи и чтения в переменную - очищает кэш и читает её честно, 
  без оптимизаций, поэтому для таких переменных volatile обычно не нужно указывать
  https://stackoverflow.com/questions/1186515/interlocked-and-volatile

Interlocked (рус.: блокировка) - статический класс создан для выполнения атомарных операций к переменным, которые доступны нескольким потокам.
Защищает переменную и от планировщика, и от того, что потоки которые будут стучаться к переменной, будут выполняться на разных процессорах.
Interlocked не вызывает исключений если правильно с ним работать.
* Завязан только под числа: double, int, uint32, uint64, long
И Exchange ещё для Object и для его потомков (с помощью generic <T>)

Методы:
	Increment, Decrement - потокобезопасное приращение или убавление 1
	Add - добавление
	Or - выполняет побитовую операцию ИЛИ
	And - выполняет побитовую операцию И
	* struct CompareExchange(ref struct location, struct value, struct comparand) - если первое и третье значения равны, то заменяет первое на второе
	* struct Exchange(ref struct, struct) - обмен значениями, возвращает исходное значение первой переменной. 

В основном используется метод Exchange(ref int, int)

Примеры:
if (0 == Interlocked.Exchange(ref _usingResource, 1))
{
	Console.WriteLine("Acquired the lock");

	Interlocked.Exchange(ref usingResource, 0);	
}
Или
if (Interlocked.CompareExchange(ref _usingResource, 1, 0))
{
	Console.WriteLine("Acquired the lock");
	
	Interlocked.Exchange(ref usingResource, 0);	
}

Хороший пример с MSDN для создания потокобезопасного добавления в общую переменную значения:
https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.interlocked.compareexchange?view=net-6.0#system-threading-interlocked-compareexchange(system-int32@-system-int32-system-int32)

public class ThreadSafeSum 
{
    private int totalValue = 0;
    public int Total => totalValue;

    public int AddToTotal(int addend) 
    {
        int initialValue, computedValue;
        do 
		{
            initialValue = totalValue;
            computedValue = initialValue + addend;
        } 
		while (initialValue != Interlocked.CompareExchange(ref totalValue, computedValue, initialValue));
        
		return computedValue;
    }
}