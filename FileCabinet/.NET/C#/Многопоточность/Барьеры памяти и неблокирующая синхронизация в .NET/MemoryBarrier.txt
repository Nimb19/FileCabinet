Барьеры памяти и неблокирующая синхронизация в .NET
https://habr.com/ru/post/130318/

MemoryBarrier

Пример:
class ReorderTest
{
   private int _a;

   public void Foo()
   {
       var task = new Task(Bar);
       task.Start();
       Thread.Sleep(1000);
       _a = 0;
       task.Wait();
   }

   public void Bar()
   {
       _a = 1;
       while (_a == 1)
       {
       }
   }
}

Пример зависнет навсегда потому, что компилятор применит для _a свою оптимизацию и эта _a будет закэширована в процессоре.
Что бы пример не зависал нужно отменить любую оптимизацию компилятора ключ. словом volatile:

private volatile int _a;

НО, запрет оптимизации - это не единственный эффект ключевого слова volatile.


!!! Любой современный процессор может переставлять инструкции чтения и записи памяти в целях оптимизации.

Для решения данной проблемы существует универсальный метод — добавление барьера памяти(memory barrier, memory fence).
Существует несколько видов барьеров памяти: полный, release fence и accure fence.

Полный барьер гарантирует, что все чтения и записи расположенные до/после барьера будут выполнены так же до/после барьера, 
то есть никакая инструкция обращения к памяти не может перепрыгнуть барьер.


Теперь разберемся с двумя другими видами барьеров:
1) Accure fence гарантирует что инструкции, стоящие после барьера, не будут перемещены в позицию до барьера.
2) Release fence гарантирует, что инструкции, стоящие до барьера, не будут перемещены в позицию после барьера.

Еще пару слов о терминологии. 
Термин volatile write означает выполнение записи в память в сочетании с созданием release fence. 
Термин volatile read означает чтение памяти в сочетании с созданием accure fence.


.NET предоставляет следующие методы работы с барьерами памяти:
    метод Thread.MemoryBarrier() создает полный барьер памяти
    ключевое слово volatile превращает каждую операцию над переменной, помеченной этим словом в volatile write или volatile read соответственно.
    метод Thread.VolatileRead() выполняет volatile read
    метод Thread.VolatileWrite() выполняет volatile write


Вернемся к нашему примеру. 
Как мы уже поняли, проблема может возникнуть из-за перестановки инструкций чтения. 
Для её решения добавим барьер памяти между чтениями _a и _b. 
После этого у нас появляется гарантия того, что поток, в котором исполняется метод Bar, увидит записи в верном порядке.

class ReorderTest2
{
   private int _a;
   private int _b;

   public void Foo()
   {
       _a = 1;
       _b = 1;
   }

   public void Bar()
   {
       if (_b == 1)
       {
           Thread.MemoryBarrier();
           Console.WriteLine(_a);
       }
   }
}

Использование полного барьера памяти здесь избыточно.
Для исключения перестановки инструкций чтения вполне достаточно воспользоваться volatile read при чтении _a.
Этого можно достичь с помощью метода Thread.VolatileRead или ключевого слова volatile.
