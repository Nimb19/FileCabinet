abstract System.Threading.WaitHandle : IDisposable
https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.waithandle?view=net-6.0


Реализует работу по ожиданию, использованию хэндлов + обобщает абстрактно реализацию.
Класс реализует общие статические и не статические методы, которые помогают работать с производными классами как с чем то общим.

Объекты, наследуемые от WaitHandle - впринципе орудуют примитивами синхронизации с ОС + абстрактно привязаны к состояниям примитивов.
То есть все производные - являются объектами у которых либо есть, либо нет какого-то сигнального состояния.
Для Mutex'а и Semaphore - сигнальное когда они залочены (взял объект под лок, или взяли монетку) 
	или, для событий синхронизации, когда они в сигнальном состоянии - типо второй поток уже сказал что событие произошло и флаг ещё не сброшен.

! Важно Dispose(), поэтому нужно не забывать использовать в try/finally

static bool SignalAndWait(WaitHandle, WaitHandle) - подаёт сигнал одному объекту WaitHandle и ожидает сигнал другого. 
	Возвращает только true (если действия завершаются удачно)
static bool SignalAndWait(WaitHandle, WaitHandle, Int32 ms, bool) - то же, только ожидая кол-во миллисекунд. 
	Перегрузка с флагом выхода из домена синхронизации до начала ожидания \\TODO: не знаю что это, что то связано с SynchronizationContext 

static bool WaitOne(WaitHandle) - очевидно просто ожидание сигнала от производного типа
static bool WaitAll(WaitHandle[]) - ожидает все
static bool WaitAny(WaitHandle[]) - ожидает какой то один
public virtual void Close(); - открытая реализация Dispose(true) - то есть вызывается только если WaitHandle освобождён явно, а не деструктором
