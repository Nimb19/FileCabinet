1. Домен синхронизации (Synchronization domain) - 
В контексте синхронизации потоков - набор контекстов и объектов, совместно использующих одну блокировку.

2. При параллелизации любого кода главная цель - использовать ресурсы компа на максимум, без чрезмерной параллелизации
   В большинстве систем - лучший способ использовать многопоточность и параллелизацию, так что бы это было бы выгоднее - использовать для внешних циклов.
   А для внутренних только если большой кусок кода.
	   - Внутренний цикл очень длинный
	   - С каждым заказом вы выполняете дорогостоящие вычисления
	   - Целевая система имеет достаточно процессоров для обработки того количества потоков, которое будет создано при параллелизации запроса

3. Вне локов и блокировок - при изменении/чтении каких то численных переменных из разных потоков есть два пути, которые обычно не надо совмещать:
   a) volatile, Volatile.Read/Write - гарантия, что потоки будут работать с одной и той же переменной, НО, не путать с оптимизациями чтения/записи других переменных в текущем потоке.
      Не безопасно при наращении. Потому что, что бы прибавить что нибудь или отнять надо прочитать, прибавить и присвоить, что не поможет при гонке потоков.
	  Защищает от оптимизаций (перемещения чтения/записи ДРУГИХ переменных в текущем потоке), но не защищает от гонки потоков записи/чтения.
   b) Interlocked - будет записывать атомарно и напрямую в память. 
	  Потокобезопасно всегда из-за атомарности добавления и чтения напрямую из памяти, очищая кэш если он был между где то.
	  Защищает от гонки потоков записи/чтения, но не от оптимизаций (перемещения чтения/записи ДРУГИХ переменных в текущем потоке).

	От оптимизаций чтения из кэша, а не из памяти - защищают оба способа. Поэтому значение всегда в обоих случаях будет актуальным.
	А вот значение других переменных, нифига может не быть актуальным.

	Вообщем, судя по форумам, смешивать volatile и Interlocked может быть вполне полезно, 
	но volatile всегда добавляется, если речь о нескольких переменных, которыми орудуем между потоками 
	(ИЛИ, если мы не используем Interlocked, появляются другие страхи оптимизации, которые могут повлиять и на одну переменную, поэтому надо всё таки volatile).
	А Interlocked не нужно, когда нет гонки потоков на запись/чтение. Такое бывает когда единично из какого нибудь потока должны выставить, например bool.
	Если есть гонка и переменных, которые как то зависят от состояния друг друга, несколько (от чего оптимизация опасна), то надо смешивать.

	Ещё лучше пример нашёл - флаг о дисконнекте с сервисом/клиентом.
	: Поток например на сеть: IsStarted, IsConnected
	: IsReadOnly, ConnectionsCount

	Банальный пример - булева переменная, к примеру, отмены (_isCancel). 
	Ждём пока все потоки (на обновление чего-нибудь параллельно) завершаться, 
	после чего в основном должны перечитать переменную и проверить, выставил ли кто то флаг отмены в true.
	И что бы гарантированно проверять/записывать состояние из каждого потока, 
	либо каждый раз нужно выставлять Volatile.Write/Read, либо ключ. словом volatile выставить переменную.

	+ volatile подходит для классов, например надо иногда в переменной назначать/обновлять ссылку на объект.
	  Если хотя бы что то из этого может быть правдой и какой то поток вполне может изменить ссылку на другую 
	  или изменить на null, или назначить что то вместо null - то обязательно надо использовать volatile.

4. В чём отличие Slim и обычных примитивов синхронизации? 
   Обычные абстракции сразу лезут в ядро, что тяжеловато. 
   Slim версии облегчены, но они для использования в конкретном своём приложении.
   Monitor.Enter и lock(obj) это можно сказать Slim версия Mutex - перед тем как уйти в долгое ожидания разблокировки объекта 
   они покрутятся ещё немного в SpinWait, в ожидании быстрой разблокировки.

5. Обращай внимание на то есть ли модификация коллекции во время её перебора. Никому обычно не нужно это, но слышал на собеседовании могут спрашивать.

6. Из await мы вполне легко можем выйти уже иной поток. 
   Поэтому например в lock(){нельзя использовать await}. Так как не сможем отпустить Monitor.Exit будучи в другом потоке