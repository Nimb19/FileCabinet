Parallel Linq
https://learn.microsoft.com/ru-ru/dotnet/standard/parallel-programming/introduction-to-plinq

Что выбрать Parallel или PLINQ? В общем случае Parallel быстрее будет останавливать потоки
	https://habr.com/ru/post/135942/

.AsParallel().AsOrdered()

Особенности: 
! Ключ. момент - простота использования. Но накладные расходы на распараллеливания могут и перевесить. Читай 1 особенность.

1. https://stackoverflow.com/questions/37133104/performances-of-plinq-vs-tpl
И PLINQ и Parallel в первую очередь создавались для рабочих нагрузок, поэтому там присутствует высокая степень оптимизации 
	(смотрят на доступные ресурсы компьютера, распределяют задачи оптимальным образом по процессорам, если нагрузка становится не сбалансированной), 
которая, на маленьких объёмах данных, может только мешать процессу (например обычные потоки ввода/вывода значения в WriteLine).

Поэтому на больших коллекциях/больших кусках кода в потоках - выгоднее будет использовать подобное распараллеливание. 
Хотя это не доказано и по большому счёт нужно профилировать приложение, измерять что будет использовать выгоднее.

2. При этом Parallel разделяет источник по нескольким частям, что бы цикл мог параллельно работать, 
и даже позволяет задать собственный разделитель или планировщик. Массив бьётся по частям, и эти части на 4 ядрах процессора обрабатываются параллельно.
3. Позволяет: 
	отслеживать состояние цикла из другого потока;
	прервать цикл токеном отмены;
	обслуживать локальное состояние потока;
	управлять степенью параллелизма.
4. Естественно, результат параллельного запроса не будет упорядочен скорее всего. 
   Нельзя предсказать порядок, от одного компа к другому степени могут автоматически меняться.
   И нельзя даже на одной машине, т.к. разные процессы могут в разное время блокировать какие-то ядра своими потоками.
   НО, можно явно указать .AsOrdered(), и тогда результат будет собран в упорядоченную последовательность.

Методы: 
(ParallelLoopResult - структура, которая говорит был ли завершён цикл и на какой итерации, если был)

1. ParallelLoopResult ForAll(this IEnumerable<T>, Action<T>) - загружаем коллекцию и выполняем делегат для каждого элемента
2. Aggregate - перегрузка от PLINQ, позволяющая объединить какие-то результаты, сделав это параллельно
+ куча методов (First,Except, GroupBy и т.д. из обычного Linq)
+ Перегрузки поддерживают типизированные доступ (<T>), токены отмены, различные настройки распараллеливания //TODO: допиши.

Впринципе можно особенности глянуть в книге
Шаблоны параллельного программирования: описание и применение в .NET Framework 4.

Расширения:
1. AsParallel - для обычного Linq. Точка входа PLINQ, указывает на параллелизацию остального запроса
2. AsSequential - указывает, что последующая часть запроса должна выполниться синхронно
3. AsOrdered - сохранить ли порядок коллекции до конца запроса PLINQ, если конечно не будет вызвана OrderBy
4. AsUnordered (по умолчанию) - можно не сохранять порядок исходной последовательности. 
   Например, если упорядочивание было включено для каких то запросов, для оптимизации можно далее это отключить
5. WithCancellation - указывает на то что надо иногда чекать токен и отменить если что запрос
6. WithDegreeOfParallelism - максимальное кол-во процессоров, которое PLINQ должен использовать для оптимизации запроса
7. WithMergeOptions - позволяет указать опции для объединения результатов в одну последовательность
8. WithExecutionMode - указывает должен ли PLIQ параллелизовать запрос


Пример https://professorweb.ru/my/LINQ/PLINQ/level16/16_2.php
Просто указываем AsParallel(), и запрос автоматически будет распараллелен, красота.
```
string[] cars = { "Nissan", "Aston Martin", "Chevrolet", "Alfa Romeo", "Chrysler", "Dodge", "BMW",
                              "Ferrari", "Audi", "Bentley", "Ford", "Lexus", "Mercedes", "Toyota", "Volvo", "Subaru", "Жигули :)"};

// Последовательный запрос LINQ
IEnumerable<string> auto = cars.Where(p => p.Contains("s"));

foreach (string s in auto)
    Console.WriteLine("Результат последовательного запроса: " + s);

// Запрос Parallel LINQ
auto = cars.AsParallel()
    .Where(p => p.Contains("s"));

foreach (string s in auto)
    Console.WriteLine("Результат параллельного запроса: " + s);
```