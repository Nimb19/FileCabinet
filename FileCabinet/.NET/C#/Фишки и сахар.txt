1. record (immutable) class/struct - неизменяемые классы, которые заполняют свои значения в конструкторе и дальше ток читаются.
   https://metanit.com/sharp/tutorial/3.51.php
   Но работает неизменяемость только для свойств, у которых вместо set; - init, к примеру.
   Они могут быть абстрактными, их можно наследовать, а можно добавить sealed.

   Есть не только визуальные, но и логические изменения:
   a) Автоматически генерируемая проверка на равенство по значениям (Equals())
   b) Автоматом реализованы проверки на равенство операторами == и != (так же по значению)
   c) Копирование с помощью ключ. слова with (person2 = person1 with { // ставим значения свойствам, которые хотим поменять (можно оставить пустые) \\ })
   d) Деконструктор var (personName, personAge) = person;
   e) Удобный автоконструктор, не надо прописывать его конкретно вместе со свойствами. Прям в определении скобки с названиями свойств. 
      Удобно, читабельно. Можно совмещать с явно указываемыми свойствами.
      public record Person(string Name, int Age)
      {
          public string Company { get; set; } = "";
      }
      Или
      public record Person(string Name, int Age);
    f) Для структур иммутабельность не работает автоматом. Там надо добавить ключ. слово readonly, сто бы иммутабельность работала
    public readonly record struct Person(string Name, int Age);
    g) Автогенерируемое ToString() -> Console.WriteLine(person); // Person {Name = Tom, Age = 37}
       Что так же поможет сравнивать по значению.

   Как и обычные классы, могут наследоваться и даже от таких же Records.
   ! Отличие только в автогенерируемом коде и доп. сахаре.

2. https://ru.stackoverflow.com/questions/535410/%D0%9F%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B8%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-volatile-read-write
   Компилятор имеет полное право передвигать инструкции так, что бы в одном конкретном потоке - логика не нарушалась. 
   Для разных процессоров оптимизация идёт по разному, для каких то (под x86) почти нет перестановок, для ARM - очень жестокие.
   И со временем оптимизаций будет только больше.
   
   !!! Предыстория для Read - компилятор имеет полное право не перечитывать переменную, если видит что в данном потоке она не меняется.
   	! Однако операции Volatile.Write/Read, lock, Thread.Start/Join и т.п. 
   	  являются критическими точками для компилятора, и оптимизация проходит только между ними.
   
   !!!!!!! Поведение под отладкой и в Release - тут действительно сильно может повлиять на результат оптимизации

3. https://ru.stackoverflow.com/questions/945941/c-wpf-%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D0%BF%D1%83%D1%81%D1%82%D0%BE%D0%B9-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B
   Пустое приложение запускается сразу с 10+ потоками внутри обычно. 
   Поток 0 Main, в WPF обычно занят циклом обработки сообщений.
   Потоков 7 из тред пула (используются для быстрого запуска процесса, потом ждут работы) (из нативного пула винды).
   Один служебный поток CLR Debugger Thread, обеспечивающий работу отладчиков управляемого кода.
   Один служебный поток CLR Finalizer Thread, запускает финализаторы (не Garbage collector).
   Один служебный поток CLR GC Thread.

   Ну и если мы посмотрим утилитой, то заметим ещё один, у которого в стеке ntdll!DbgUiRemoteBreakin. 
   Это инжектированный поток для отладки, но к приложению он не относится.

4. Почитай про ограничения структур. Например, упаковка структур в ссылочный тип (к примеру IDisposing) 
   скопирует структуру в кучу, поэтому Disposing вызовется у скопированного объекта.
   Видишь интерфейс у структуры - НАПРЯГИСЬ, это скорее всего баг. Никаких блять IDisposable у структур.
   Почитай про то как использоваться интерфейсы в структуре и какие ограничения будут у структуры.

5. Структура не может содержать в себе данные с неизвестной длиной, поэтому мы не можем создать в ней поле, которое может ссылаться на само себя.
   Тут как раз приходит то, как работает ключ. слово default - в стеке просто нулевыми значениями записывает переменные, а для ссылочных переменных просто null.
   Для структур просто резервируется память.
   При чём если структура будет полем какого-то класса, то она будет храниться в куче, рядом с объектом, но это только текущая реализация и .NET вполне может изменить схему.
   Если boxing не применён, то она хранится на стеке.

6. Когда применять IDisposable, а когда финализатор? В c# неизвестно когда вызовется финализатор, 
   поэтому если мы не задиспоузили какой-то stream, который держал файл, то финализатор (который вызывает dispose почти всегда) не понятно когда вызовется, 
   значит файл будет висеть объектом, на который не будет ссылки. 
   Не возможно вызвать деструктор в подходящий момент, а вот Dispose() можно.
   
   Любой самостоятельный объект, который сам что то за вас делает, нужно диспоузить, иначе, они будут работать (в т.ч. тики таймера) 
   пока их деструктор не будет вызван.



Если хочется оптимизировать что то, напоминания: 
(во первых можно ли какой то объект превратить в структуру, это много может дать, если не придётся боксить часто)

1. readonly ref struct - означает что объект этого типа сто процентов будет на стеке. 
   Ограничения: 
   1) Нельзя реализовывать интерфейсы. Иначе после приведения к ним пришлось бы боксить.
   2) Объект этого типа можно сохранять в переменную только сущности с таким же типом readonly ref struct
2. ReadOnlySpan<T> - можно использовать вместо Substring к примеру. 
   Класс хранит в себе по сути ссылку на исходную строку и индексы откуда читать и где заканчивать чтение.
   Тем самым, если мы часто преобразуем какие-то объекты, например, строки, можно это делать без создания новых. 
   Это даёт большой прирост производительности.
3. Профилировка - dotTrace