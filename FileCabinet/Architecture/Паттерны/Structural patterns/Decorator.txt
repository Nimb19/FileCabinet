Паттерн "Декоратор" (на рус. - обёртка)
https://refactoring.guru/ru/design-patterns/decorator

! Разница между Proxy и Decorator https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern 
  Прокси знает конкретный тип, к которому проксирует трафик, а Декоратор обвязывает обобщённый тип, разницы практически нет.


Используется как одежда на людях, просто обёртка поверх какого-то интерфейса, что бы потом объект, 
реализующий этот интерфейс можно было обернуть под какую-нибудь логику, используя и прокидывая объект дальше.

Как создать и использовать:
1. Создать базовый абстрактный декоратор который берёт в конструкторе ссылку на объект, который обёртываем и реализует для него каждый метод просто вызвав их.
2. Создать конкретный декоратор, который был нужен, наследовав его от базового декоратора и переопределив методы, которые были нужны.

var emailNotifier = new EmailNotifier();
emailNotifier = new SlackNotifier(emailNotifier);
return emailNotifier;

Преимущества:
1. Большая гибкость для развития функционала, чем от наследования, в случаях когда не понятно от чего наследоваться, как минимум.
2. Может вполне выполнять свои действия многопоточно.
3. Клиент берёт на себя возможность выбора порядка и конкретных декораторов.
4. Создаётся и используется на лету, очень легко применять, вроде.

// По сути нужен когда надо расширить возможности не конкретного объекта, а интерфейса. 
// Когда порядок вызова обёрток важен для конкретной ситуации, как процессы на чтение/запись.
// Ну или, очевидно, когда от класса нельзя наследоваться.

// Ну норм для префикс-логгера.
// Норм кстати для input/output операций каких-нибудь. Сжать/разжать какой-то Stream, к примеру.
