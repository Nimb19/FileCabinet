1. Инвариант - выражение, которое сохраняет своё значение при любых махинациях с объектом. 
   То есть ну не может быть элементов в коллекции больше чем свойство количесва и меньше нуля.
   Такие инварианты проверяются в коде в виде конструкций Contract.Assert(bool);
   https://ru.stackoverflow.com/questions/858650/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8%D0%BD%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82-%D0%B2-%D0%9E%D0%9E%D0%9F
   Debug.Assert'ы - когда хотим следить за контрактом только на этапе отладки (типа в контрукции #IF DEBUG)
   Contract.Assert'ы - если вы хотите убедиться и на этапе отладки и в выпущенной версии.
   https://stackoverflow.com/questions/20603510/debug-assert-vs-code-contract-usage

2. Когда использовать Transient вместо Scoped - когда хотим, что бы в рамках скоупа - у разных сервисов были разные инстанцы объекта.
   Абстрактно: если хотим изолировать объект для сервиса - надо ставить Transient. 
   ! Но важно учесть реалии, что подписывающиеся сервисы не очень хорошо брать как Transient, если конекшены чем то сильно ограничены, 
   то их может не хватать. Хотя если сделать реализацию Scoped - да, это не безопасно, даже если сервис потокобезопасен. в случае с DbContext.
   Другой сервис может вызвать SaveChanges() не во время и т.д.

   То есть для Scoped - у сервисов будет один и тогт же экземпляр объекта, для Transient - у всех сервисов будет свой (довольно затратно, подумай дважды).

   Не забывай про многопоточность подумать - когда ставишь Scoped, Singleton.


Срёмся за термины чаще чем юристы:

2. IoC (Inversion of control) - когда не мы вызваем код, а код вызывает нас.
3. DI-контейнер - позволяет разделить описание зависимостей и сами объекты. 
   Он сам пробрасывает нужные зависимости объектам с нужными настройками лайфтайма. Порождает наши объекты.
4. DIP (SOLI D = DIP (Dependency inversion principal)) - принцип говорит нам какими зависимости должны быть. 
   И при этом не хорошо зависеть от конкретных реализаций, лучше от интерфейсов.
   (например, контроллер зависит от сервиса, а сервис от инфраструктуры, поэтому очень не очень пробрасывать в контроллер DbContext)
   (ну или вообще будет хаус в репозитории (инфраструктуре) инжектить каким то образом контроллер)

   По книжному - абстракции не должны зависеть от деталией, детали должны зависеть от абстракций.
   То есть каждая абстракиция по хорошему должна зависеть от интерфейсов, других абстракций.
   При этом когда то приходим к нескольким уровням абстракций, тут точно так же, верхний уровень не должен зависеть от нижних, а нижнии должны от верхних. 
   Так по лесенке.