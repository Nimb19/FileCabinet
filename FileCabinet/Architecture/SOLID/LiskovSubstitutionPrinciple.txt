https://metanit.com/sharp/patterns/5.3.php
# Поступай разумно, не надо делать супер-ультра гибкую архитектуру с миллионом сущностей, иначе читать её будет трудно

Liskov Substitution Principle (принцип подстановки Лисков)

! Должна быть возможность вместо базового типа подставить любой его подтип.

Гласит, что если наш наследник будет уменьшать логику, то мы явно делаем что то не так. 
Нельзя уменьшать логику, можно только переопределять виртуальные методы и добавлять методы, расширять логику.
Но никак не отказываться от какой-то логики. В этом случае мы делаем что то не так.

Банальный пример:
```
class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
     
    public int GetArea()
    {
        return Width * Height;
    }
}
 
class Square : Rectangle
{
    public override int Width
    {
        get
        {
            return base.Width;
        }
 
        set
        {
            base.Width = value;
            base.Height = value;
        }
    }
 
    public override int Height
    {
        get
        {
            return base.Height;
        }
 
        set
        {
            base.Height = value;
            base.Width = value;
        }
    }
}
```

тут у нас квадрат явно переопределяет базовую логику, что не очень хорошо, так как это не написано на лице у базового класса.
То есть приведя к базовому типу и отдав код на скормление каким то другим классам 
- эти другие классы могут пытаться использовать эти значения и не понимать почему если менять у Rectangle длину стороны, то меняется другая.

Нельзя в этом случае нарушать логику базового объекта, поэтому наследовать Square от Rectangle нельзя.
Вместо этого тут можно придумать фабрику создания Rectangle как Square, 
но надо будет согласится с тем, что отдав этот объект с публичными сеттерами - квадрат могут сломать в прямоугольник.


Принцип Барбары Лисков - гласит нам, что наследовать такой класс нельзя, защищая нас от самих себя, что бы мы сразу поправили архитектуру, 
а не забивали и пользовались запоминая этот косяк. Убираем ложные иерархии, делаем иерархии качественными, стройными и не противоречивыми.

След. правила помогут в этом:
. Мы не должны усложнять предисловия, добавлять if с доп. ошибками, мы должны реализовывать все сценарии которые предусмотрены в базовом классе.
. Постусловия не должны быть ослаблены. Если результат метода не мог возвращать больше 0 условно, то результат переопределённого тоже должен идти на соглашение.
. Инварианты должны быть сохранены.
  Если базовый класс (лист) гарантирует что Count не может быть меньше 0 и должен быть равен кол-ву лежащих элементов, -> надо поддерживать.
