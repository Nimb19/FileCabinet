RMQ Queue (очереди)

Это структура данных на диске или в оперативной памяти, которая хранит ссылки на сообщения и отдаёт их копии consumers (потребителям).
Queue - это Erlang процесс с состоянием, где могут кэшироваться и сами сообщения. 1 тысяча сообщений может занимать порядка 80 мб


Типы очередей:
1. Временные очереди:
	1) Декларируются с аргументов autoDelete = True. 
	Они уничтожаются автоматически, как только от них отключатся все consumers.
	2) Декларируются с аргументом exclusive = True.
	Такая очередь создаётся только на одного потребителя, никто не сможет к ней больше подключиться, 
	и как только канал освобождается - очередь сама удаляется.
	До тех пор, пока канал не закроется, можно отключаться и подключаться, но только в рамках одного и того же соединения.
	Если указан этот аргумент, то autoDelete аргумент не будет иметь значение.

	Из особенностей:
	а) При кратковременном разрыве соединения очередь может удалиться 
	и при подключении обратно, создания новой временной очереди - могло уже потеряться какое то количество сообщений;
	б) При постоянном использовании временных очередей в одной системе - может случится перегрузка создания/удаления очередей binding churn,
	даже если перегрузки не случится, создание/удаление очередей достаточно серьёзно нагружает все узлы кластера, 
	т.к. сообщения о том, что задекларирована/удалена очередь передаётся в каждый кластерный узел.
	НО, данный процесс можно оптимизировать за счёт контроля количества подписок.
2. Постоянные очереди:
	Если очередь создаётся с параметров durable, то она будет существовать до выполнения кем-нибудь команды Queue.Delere.
	Такая queue переживёт и перезагрузку и рестарт и клиента и сервера.
	Так же такая очередь будет хранить своё состояние, оно будет восстанавливаться после каждого включения.
3. High Availability очередь (HA)
	HA очереди доступны только в кластерном режиме RabbitMq. 
	Очередь копируется на указанные или все узлы кластера, а сообщения загружаются в каждую из копий очереди.
	И не только очереди, вся информация о exchanges, bindings, queues, consumers.
	Как только какой-нибудь consumer заберёт сообщение из очереди на какой-то ноде, 
	сообщение будет удалено из очередей на других узлах.
	Такие очереди могут синхронизироваться во всех или в индивидуально выбранных узлах.

	Особенности:
	Создаёт доп. нагрузку на RabbitMq для координации очередей и копирования сообщений. 2-3 узлов обычно достаточно.


Создание очереди:
channel.QueueDeclare(
	queue: "my queue name",  // Название очереди. Должно быть уникальным! И не должно быть системным именем очереди в RabbitMq.
	durable: false,			 // Если True, то очередь будет сохранять своё состояние, и после перезапуска сервиса/перезагрузки сервера сможет восстановить свои данные
	exclusive: false,		 // Если True, то к очереди разрешается подключаться только одному consumer
	autoDelete: false,		 // Если True, то очередь способна убить сама себя, когда придёт её время
	arguments: null			 // Не обязательный аргумент для доп. какой-нибудь логики, плагинов
);

// TODO: расскажи поболее